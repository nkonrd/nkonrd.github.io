<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Niko Nordlund</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; background:#ffffff; }
    /* Prevent the browser from handling touch gestures so ours work consistently */
    canvas { display:block; width:100%; height:100%; background:#f7f7f7; touch-action:none; }
  </style>
</head>
<body>
  <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
  <script>
    // ----- Renderer -----
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0xf7f7f7, 1);
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // ----- Scene & Camera -----
    const scene  = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 100);

    let radius = 8, theta = 0, phi = Math.PI / 2;
    const R_MIN = 4, R_MAX = 20, PHI_MIN = 0.1, PHI_MAX = Math.PI - 0.1;

    function updateCamera() {
      const sinPhi = Math.sin(phi);
      camera.position.set(
        radius * sinPhi * Math.sin(theta),
        radius * Math.cos(phi),
        radius * sinPhi * Math.cos(theta)
      );
      camera.lookAt(0, 0, 0);
    }

    // ----- Lights -----
    const hemi = new THREE.HemisphereLight(0xffffff, 0xebe7e2, 0.6);
    scene.add(hemi);
    const key = new THREE.DirectionalLight(0xfff2e0, 0.9);
    key.position.set(4, 5, 8);
    scene.add(key);
    const fill = new THREE.DirectionalLight(0xe6f2ff, 0.35);
    fill.position.set(-6, 2, -5);
    scene.add(fill);

    // ----- Card geometry -----
    const size = { w: 3.37, h: 2.125, d: 0.04 };
    const geometry = new THREE.BoxGeometry(size.w, size.h, size.d);

    // ----- Materials -----
    const offWhite  = 0xfcfbf7;
    const edgeColor = 0xdadada;
    const edgeMat = new THREE.MeshStandardMaterial({ color: edgeColor, roughness: 0.35, metalness: 0.02 });
    const faceMat = new THREE.MeshStandardMaterial({ color: offWhite, roughness: 0.6, metalness: 0.0 });

    // ----- Face texture (monospace, left-aligned) -----
    function makeFaceTexture() {
      const W = 1024, H = 512;
      const canvas = document.createElement("canvas");
      canvas.width = W; canvas.height = H;
      const ctx = canvas.getContext("2d");

      ctx.fillStyle = "#fcfbf7";
      ctx.fillRect(0, 0, W, H);

      const fontFamily = "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillStyle = "#111111";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.font = "44px " + fontFamily;

      const marginX = 80;
      const marginY = 200;
      const lineHeight = 60;

      ctx.fillText("Niko Nordlund, BSc", marginX, marginY);
      ctx.fillText("Doctoral researcher", marginX, marginY + lineHeight);

      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = 4;
      tex.encoding = THREE.sRGBEncoding;
      return tex;
    }

    const frontMat = faceMat.clone(); frontMat.map = makeFaceTexture();
    const backMat  = faceMat.clone();

    const card = new THREE.Mesh(geometry, [edgeMat, edgeMat, edgeMat, edgeMat, frontMat, backMat]);
    scene.add(card);

    // ----- Resize -----
    function resize() {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      updateCamera();
    }
    window.addEventListener("resize", resize);
    resize();

    // ===== Pointer Events controls (mouse + touch + pen) =====
    const el = renderer.domElement;
    const ROTATE_SPEED = 0.005;       // drag sensitivity
    const PINCH_ZOOM_SPEED = 0.003;   // pinch sensitivity
    const WHEEL_ZOOM_SPEED = 0.0015;  // wheel sensitivity

    // Auto-rotate on open; stop on first interaction (no auto-resume)
    let autoRotate = true;
    let lastTime = performance.now();

    // Track active pointers
    const pointers = new Map(); // id -> {x,y}
    let isRotating = false;
    let lastCenter = null;
    let lastPinchDist = null;

    function pointerPos(e) { return { x: e.clientX, y: e.clientY }; }
    function centerOfPointers() {
      let sx = 0, sy = 0, n = 0;
      pointers.forEach(p => { sx += p.x; sy += p.y; n++; });
      return n ? { x: sx / n, y: sy / n } : null;
    }
    function distanceAB(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    function stopAuto() { autoRotate = false; }

    el.addEventListener("pointerdown", (e) => {
      el.setPointerCapture(e.pointerId);
      pointers.set(e.pointerId, pointerPos(e));
      stopAuto();

      if (pointers.size === 1) {
        isRotating = true;
        lastCenter = centerOfPointers();
        lastPinchDist = null;
      } else if (pointers.size === 2) {
        isRotating = false;
        const pts = Array.from(pointers.values());
        lastPinchDist = distanceAB(pts[0], pts[1]);
        lastCenter = centerOfPointers();
      }
    });

    el.addEventListener("pointermove", (e) => {
      if (!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId, pointerPos(e));
      const n = pointers.size;

      if (n === 1 && isRotating) {
        const c = centerOfPointers();
        if (c && lastCenter) {
          const dx = c.x - lastCenter.x;
          const dy = c.y - lastCenter.y;
          // Natural "object drag" feel on all devices:
  	theta -= dx * ROTATE_SPEED;
	phi   -= dy * ROTATE_SPEED; // ← flipped

          phi = Math.max(PHI_MIN, Math.min(PHI_MAX, phi));
          updateCamera();
        }
        lastCenter = c;
      } else if (n === 2 && lastPinchDist != null) {
        const pts = Array.from(pointers.values());
        const d = distanceAB(pts[0], pts[1]);
        const delta = d - lastPinchDist;
        radius = Math.max(R_MIN, Math.min(R_MAX, radius * Math.exp(-delta * PINCH_ZOOM_SPEED)));
        updateCamera();
        lastPinchDist = d;

        // Allow rotating while pinching by also tracking center movement
        const c = centerOfPointers();
        if (c && lastCenter) {
          const dx = c.x - lastCenter.x;
          const dy = c.y - lastCenter.y;
	theta -= dx * ROTATE_SPEED * 0.6;
	phi   -= dy * ROTATE_SPEED * 0.6; // ← flipped
          phi = Math.max(PHI_MIN, Math.min(PHI_MAX, phi));
          updateCamera();
        }
        lastCenter = c;
      }
    });

    el.addEventListener("pointerup", (e) => {
      if (pointers.has(e.pointerId)) pointers.delete(e.pointerId);
      if (pointers.size === 0) { isRotating = false; lastCenter = null; lastPinchDist = null; }
      if (pointers.size === 1) { isRotating = true; lastCenter = centerOfPointers(); }
    });

    el.addEventListener("pointercancel", (e) => {
      if (pointers.has(e.pointerId)) pointers.delete(e.pointerId);
      isRotating = false; lastCenter = null; lastPinchDist = null;
    });

    // Wheel zoom (desktop)
    el.addEventListener("wheel", (e) => {
      e.preventDefault();
      stopAuto();
      const factor = Math.exp(e.deltaY * WHEEL_ZOOM_SPEED);
      radius = Math.max(R_MIN, Math.min(R_MAX, radius * factor));
      updateCamera();
    }, { passive: false });

    // Context menu can get in the way while dragging
    el.addEventListener("contextmenu", (e) => e.preventDefault());

    updateCamera();

    // ----- Render loop -----
    function render(now) {
      const delta = now - lastTime;
      lastTime = now;

      if (autoRotate) {
        theta += -delta * 0.001;
        updateCamera();
      }

      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
    render(performance.now());
  </script>
</body>
</html>
