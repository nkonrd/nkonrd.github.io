<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Niko Nordlund</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; background:#ffffff; }
    canvas { display:block; width:100%; height:100%; background:#f7f7f7; touch-action:none; }
  </style>
</head>
<body>
  <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
  <script>
    // ----- Renderer -----
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0xf7f7f7, 1);
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // ----- Scene & Camera -----
    const scene  = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 100);

    let radius = 8, theta = 0, phi = Math.PI / 2;
    const R_MIN = 4, R_MAX = 20, PHI_MIN = 0.1, PHI_MAX = Math.PI - 0.1;

    function updateCamera() {
      const sinPhi = Math.sin(phi);
      camera.position.set(
        radius * sinPhi * Math.sin(theta),
        radius * Math.cos(phi),
        radius * sinPhi * Math.cos(theta)
      );
      camera.lookAt(0, 0, 0);
    }

    // ----- Lights -----
    const hemi = new THREE.HemisphereLight(0xffffff, 0xebe7e2, 0.6);
    scene.add(hemi);
    const key = new THREE.DirectionalLight(0xfff2e0, 0.9);
    key.position.set(4, 5, 8);
    scene.add(key);
    const fill = new THREE.DirectionalLight(0xe6f2ff, 0.35);
    fill.position.set(-6, 2, -5);
    scene.add(fill);

    // ----- Card geometry -----
    const size = { w: 3.37, h: 2.125, d: 0.04 };
    const geometry = new THREE.BoxGeometry(size.w, size.h, size.d);

    // ----- Materials -----
    const offWhite  = 0xfcfbf7;
    const edgeColor = 0xdadada;
    const edgeMat = new THREE.MeshStandardMaterial({ color: edgeColor, roughness: 0.35, metalness: 0.02 });
    const faceMat = new THREE.MeshStandardMaterial({ color: offWhite, roughness: 0.6, metalness: 0.0 });

    // ----- Face texture -----
    function makeFaceTexture() {
      const W = 1024, H = 512;
      const canvas = document.createElement("canvas");
      canvas.width = W; canvas.height = H;
      const ctx = canvas.getContext("2d");

      ctx.fillStyle = "#fcfbf7";
      ctx.fillRect(0, 0, W, H);

      const fontFamily = "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillStyle = "#111111";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.font = "44px " + fontFamily;

      const marginX = 80;
      const marginY = 200;
      const lineHeight = 60;

      ctx.fillText("Niko Nordlund, BSc", marginX, marginY);
      ctx.fillText("Doctoral researcher", marginX, marginY + lineHeight);

      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = 4;
      tex.encoding = THREE.sRGBEncoding;
      return tex;
    }

    const frontMat = faceMat.clone();
    frontMat.map = makeFaceTexture();
    const backMat = faceMat.clone();

    const card = new THREE.Mesh(geometry, [edgeMat, edgeMat, edgeMat, edgeMat, frontMat, backMat]);
    scene.add(card);

    // ----- Resize -----
    function resize() {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      updateCamera();
    }
    window.addEventListener("resize", resize);
    resize();

    // ----- Controls (mouse + touch) -----
    let dragging = false, lastX = 0, lastY = 0;
    let lastDist = null; // for pinch zoom
    const ROTATE_SPEED = 0.005, ZOOM_SPEED = 0.0015;

    let autoRotate = true;
    let lastTime = performance.now();
    let idleTimer = null;

    function stopAutoRotate() {
      autoRotate = false;
      if (idleTimer) clearTimeout(idleTimer);
      idleTimer = setTimeout(() => { autoRotate = true; }, 6000);
    }

    // Mouse
    window.addEventListener("mousedown", e => { dragging = true; lastX = e.clientX; lastY = e.clientY; stopAutoRotate(); });
    window.addEventListener("mousemove", e => {
      if (!dragging) return;
      const dx = e.clientX - lastX, dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      theta += dx * ROTATE_SPEED;
      phi   -= dy * ROTATE_SPEED;
      phi = Math.max(PHI_MIN, Math.min(PHI_MAX, phi));
      updateCamera();
    });
    window.addEventListener("mouseup", () => dragging = false);
    window.addEventListener("wheel", e => {
      e.preventDefault(); stopAutoRotate();
      const factor = Math.exp(e.deltaY * ZOOM_SPEED);
      radius = Math.max(R_MIN, Math.min(R_MAX, radius * factor));
      updateCamera();
    }, { passive: false });

    // Touch support (1 finger = rotate, 2 = pinch zoom)
    window.addEventListener("touchstart", e => {
      stopAutoRotate();
      if (e.touches.length === 1) {
        dragging = true;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        dragging = false;
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastDist = Math.sqrt(dx*dx + dy*dy);
      }
    }, { passive: false });

    window.addEventListener("touchmove", e => {
      e.preventDefault();
      if (e.touches.length === 1 && dragging) {
        const x = e.touches[0].clientX, y = e.touches[0].clientY;
        const dx = x - lastX, dy = y - lastY;
        lastX = x; lastY = y;
        theta += dx * ROTATE_SPEED;
        phi   -= dy * ROTATE_SPEED;
        phi = Math.max(PHI_MIN, Math.min(PHI_MAX, phi));
        updateCamera();
      } else if (e.touches.length === 2 && lastDist) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const factor = Math.exp((lastDist - dist) * ZOOM_SPEED);
        radius = Math.max(R_MIN, Math.min(R_MAX, radius * factor));
        updateCamera();
        lastDist = dist;
      }
    }, { passive: false });

    window.addEventListener("touchend", () => { dragging = false; lastDist = null; });

    updateCamera();

    // ----- Render loop -----
    function render(now) {
      const delta = now - lastTime;
      lastTime = now;

      if (autoRotate) {
        theta += -delta * 0.00035;
        updateCamera();
      }

      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
    render(performance.now());
  </script>
</body>
</html>
