<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Niko Nordlund</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height:100%; margin:0; background:#ffffff; }
    canvas { display:block; width:100%; height:100%; background:#f7f7f7; } /* softer bg */
  </style>
</head>
<body>
  <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
  <script>
    // ----- Renderer -----
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0xf7f7f7, 1); // soft light gray background
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // ----- Scene & Camera -----
    const scene  = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 100);

    let radius = 8, theta = 0, phi = Math.PI / 2;
    const R_MIN = 4, R_MAX = 20, PHI_MIN = 0.1, PHI_MAX = Math.PI - 0.1;

    function updateCamera() {
      const sinPhi = Math.sin(phi);
      camera.position.set(
        radius * sinPhi * Math.sin(theta),
        radius * Math.cos(phi),
        radius * sinPhi * Math.cos(theta)
      );
      camera.lookAt(0, 0, 0);
    }

    // ----- Lights (warmer key, cooler fill, soft ambient) -----
    // Hemisphere for gentle ambient wrap
    const hemi = new THREE.HemisphereLight(0xffffff, 0xebe7e2, 0.55);
    scene.add(hemi);

    // Warm key light
    const key = new THREE.DirectionalLight(0xfff2e0, 0.9);
    key.position.set(4, 5, 8);
    scene.add(key);

    // Cool fill light opposite direction
    const fill = new THREE.DirectionalLight(0xe6f2ff, 0.35);
    fill.position.set(-6, 2, -5);
    scene.add(fill);

    // ----- Card geometry (credit card size in inches) -----
    const size = { w: 3.37, h: 2.125, d: 0.04 };
    const geometry = new THREE.BoxGeometry(size.w, size.h, size.d);

    // ----- Colors & materials -----
    const offWhite  = 0xfcfbf7;   // slightly warmer
    const edgeColor = 0xdadada;   // a touch darker for definition

    const edgeMat = new THREE.MeshStandardMaterial({
      color: edgeColor,
      roughness: 0.35,  // a bit glossier
      metalness: 0.02
    });
    const faceMat = new THREE.MeshStandardMaterial({
      color: offWhite,
      roughness: 0.6,   // more matte face
      metalness: 0.0
    });

    // ----- Front face texture with left-aligned monospace text -----
    function makeFaceTexture() {
      const W = 1024, H = 512;
      const canvas = document.createElement("canvas");
      canvas.width = W; canvas.height = H;
      const ctx = canvas.getContext("2d");

      // Background (match faceMat color)
      ctx.fillStyle = "#fcfbf7";
      ctx.fillRect(0, 0, W, H);

      // Text setup
      const fontFamily = "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
      ctx.fillStyle = "#111111";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.font = "44px " + fontFamily;

      const marginX = 80;
      const marginY = 200;
      const lineHeight = 60;

      ctx.fillText("Niko Nordlund, BSc", marginX, marginY);
      ctx.fillText("Doctoral researcher", marginX, marginY + lineHeight);

      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = 4;
      tex.encoding = THREE.sRGBEncoding;
      return tex;
    }

    const frontMat = faceMat.clone();
    frontMat.map = makeFaceTexture();

    const backMat  = faceMat.clone();

    const card = new THREE.Mesh(geometry, [
      edgeMat, edgeMat, edgeMat, edgeMat, frontMat, backMat
    ]);
    scene.add(card);

    // ----- Soft contact shadow (fake, no shadow maps) -----
    function makeShadowTexture(size = 512) {
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');
      const g = ctx.createRadialGradient(size/2, size/2, size*0.15, size/2, size/2, size*0.5);
      g.addColorStop(0, "rgba(0,0,0,0.24)");
      g.addColorStop(1, "rgba(0,0,0,0.00)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,size,size);
      const tex = new THREE.CanvasTexture(c);
      tex.encoding = THREE.sRGBEncoding;
      return tex;
    }

    const shadowTex = makeShadowTexture(512);
    const shadow = new THREE.Mesh(
      new THREE.PlaneGeometry(size.w * 2.2, size.h * 2.4),
      new THREE.MeshBasicMaterial({ map: shadowTex, transparent: true, depthWrite: false })
    );
    shadow.rotation.x = -Math.PI / 2;
    shadow.position.y = -(size.h * 0.55); // a little below the card
    scene.add(shadow);

    // ----- Resize -----
    function resize() {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      updateCamera();
    }
    window.addEventListener("resize", resize);
    resize();

    // ----- Mouse rotate + zoom + auto-spin until interaction -----
    let dragging = false, lastX = 0, lastY = 0;
    const ROTATE_SPEED = 0.005, ZOOM_SPEED = 0.0015;

    let autoRotate = true;
    let lastTime = performance.now();
    let idleTimer = null;

    function stopAutoRotate() {
      autoRotate = false;
      if (idleTimer) { clearTimeout(idleTimer); idleTimer = null; }
      // Optional: resume after 6s of inactivity
      idleTimer = setTimeout(() => { autoRotate = true; }, 6000);
    }

    window.addEventListener("mousedown", e => { dragging = true; lastX = e.clientX; lastY = e.clientY; stopAutoRotate(); });
    window.addEventListener("mousemove", e => {
      if (!dragging) return;
      const dx = e.clientX - lastX, dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      theta += dx * ROTATE_SPEED;
      phi   -= dy * ROTATE_SPEED;
      phi = Math.max(PHI_MIN, Math.min(PHI_MAX, phi));
      updateCamera();
    });
    window.addEventListener("mouseup", () => dragging = false);
    window.addEventListener("wheel", e => {
      e.preventDefault();
      stopAutoRotate();
      const factor = Math.exp(e.deltaY * ZOOM_SPEED);
      radius = Math.max(R_MIN, Math.min(R_MAX, radius * factor));
      updateCamera();
    }, { passive: false });

    updateCamera();

    // ----- Render loop -----
    function render(now) {
      const delta = now - lastTime;
      lastTime = now;

      if (autoRotate) {
        theta += -delta * 0.00035; // gentle spin
        updateCamera();
      }

      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
    render(performance.now());
  </script>
</body>
</html>
